#!/usr/bin/env node

const got = require('got');
const psl = require('psl');
const { connect, connection } = require('mongoose');
// const { JSDOM } = require('jsdom');
require('dotenv').config();

const Event = require('../models/event.model');
const {
  allowedHosts,
  limitedEmbedGen,
  getColors
} = require('../utils/embed-generator');

process.on('warning', e => console.warn(e.stack));

const newEvents = [];

const storeIfNotExists = async event => {
  if (!allowedHosts[event.host]) return;

  const res = await Event.findOneAndUpdate(
    event,
    { $setOnInsert: event },
    { upsert: true, new: true, rawResult: true }
  );

  res.lastErrorObject.updatedExisting || newEvents.push(res.value);
};

(async () => {
  /**
   * Connect to MongoDB instance
   */

  await connect(process.env.MONGO_URI, {
    useNewUrlParser: true,
    useFindAndModify: false,
    useCreateIndex: true,
    useUnifiedTopology: true
  });

  /**
   * Fetch data from CLIST and store in MongoDB
   */

  const clist = await got('https://clist.by/api/v2/contest/', {
    headers: { Authorization: process.env.CLIST_BEARER },
    searchParams: {
      start__gt: new Date().toISOString(),
      start__lt: new Date(
        new Date().setDate(new Date().getDate() + 5)
      ).toISOString()
    }
  }).json();

  await Promise.all(
    clist.objects
      .filter(({ event }) => /^[ -~]+$/.test(event))
      .map(e => ({
        title: e.event,
        host: e.resource,
        url: e.href,
        start: e.start,
        end: e.end
      }))
      .map(storeIfNotExists)
  );

  /**
   * Fetch data from Devfolio and store in MongoDB
   */

  const devfolio = await got('https://devfolio.co/api/hackathons', {
    searchParams: {
      filter: 'application_open',
      page: 1,
      limit: 20
    }
  }).json();

  await Promise.all(
    devfolio.result
      .filter(
        ({ hackathon_setting: hs }) =>
          new Date(hs.reg_ends_at) <
          new Date(new Date().setDate(new Date().getDate() + 5))
      )
      .map(e => ({
        title: e.name,
        description: e.desc,
        host: 'devfolio.co',
        url: `https://${e.hackathon_setting.subdomain}.devfolio.co`,
        start: e.hackathon_setting.reg_starts_at,
        end: e.hackathon_setting.reg_ends_at,
        image: e.cover_img,
        thumbnail: e.hackathon_setting.logo
      }))
      .map(storeIfNotExists)
  );

  // /**
  //  * Fetch data from Devpost and store in MongoDB
  //  */

  // const devpostURLs = new Set();
  // const devpostObjects = [];

  // await Promise.all(
  //   Array.from({ length: 5 }, (_, i) => i + 1).map(async page => {
  //     const endpoint = new URL('https://devpost.com/hackathons');
  //     endpoint.search = new URLSearchParams({
  //       challenge_type: 'all',
  //       page,
  //       sort_by: 'Prize Amount',
  //       utf8: 'âœ“'
  //     });

  //     const dom = await JSDOM.fromURL(endpoint);

  //     dom.window.document.body.innerHTML
  //       .match(/https:\/\/([-\w]+)\.devpost\.com\//g)
  //       .forEach(e => devpostURLs.add(e));

  //     devpostObjects.push(
  //       ...Object.values(
  //         JSON.parse(
  //           dom.window.document
  //             .querySelector('#challenges-json-ld')
  //             .textContent.trim()
  //         )
  //       )
  //     );
  //   })
  // );

  // ['secure', 'post', 'info', 'help', 'api'].forEach(e =>
  //   devpostURLs.delete(`https://${e}.devpost.com/`)
  // );

  // devpostObjects.forEach(e => devpostURLs.delete(e.url));

  // await Promise.all(
  //   [...devpostURLs].map(async url => {
  //     const dom = await JSDOM.fromURL(url);

  //     devpostObjects.push(
  //       JSON.parse(
  //         dom.window.document
  //           .querySelector('#challenge-json-ld')
  //           .textContent.trim()
  //       )
  //     );
  //   })
  // );

  // await Promise.all(
  //   devpostObjects
  //     .map(e => ({
  //       title: e.name,
  //       host: 'devpost.com',
  //       url: e.url,
  //       start: e.startDate,
  //       end: e.endDate
  //     }))
  //     .map(storeIfNotExists)
  // );

  /**
   * Generate and sanitize embeds
   */

  console.info(newEvents.length);

  const embeds = await Promise.all(
    newEvents.filter(e => !/hiring/i.test(e.title)).map(limitedEmbedGen)
  );
  const colors = getColors();

  embeds.forEach((element, i) => {
    if (!element.color)
      embeds[i].color =
        colors[psl.parse(new URL(element.author.url).hostname).domain] || 0;
  });

  embeds.sort(
    (a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
  );

  /**
   * Generate and send webhooks to Discord
   */

  const webhook = {
    content: null,
    embeds: []
  };

  const failed = [];

  while (embeds.length > 0) {
    webhook.embeds = embeds.splice(0, 1);
    if (webhook.embeds[0].color)
      try {
        // eslint-disable-next-line no-await-in-loop
        await got.post(process.env.WEBHOOK_URL, {
          json: webhook,
          responseType: 'json'
        });
      } catch (e) {
        console.error(e);
        failed.push(...webhook.embeds);
      }
  }

  console.warn(failed);

  await connection.close();
  process.exit();
})().catch(err => {
  console.error(err);
  process.exit(1);
});
