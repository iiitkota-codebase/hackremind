#!/usr/bin/env node

const got = require('got');
const psl = require('psl');
const TurndownService = require('turndown');
const { connect, connection } = require('mongoose');
const { JSDOM } = require('jsdom');
require('dotenv').config();

const Event = require('../models/event.model');
const {
  allowedHosts,
  limitedEmbedGen,
  getColors
} = require('../utils/embed-generator');

process.on('warning', e => console.warn(e.stack));

const newEvents = [];

const storeIfNotExists = async event => {
  if (!allowedHosts[event.host]) return;

  const res = await Event.findOneAndUpdate(
    event,
    { $setOnInsert: event },
    { upsert: true, new: true, rawResult: true }
  );

  res.lastErrorObject.updatedExisting || newEvents.push(res.value);
};

(async () => {
  /**
   * Connect to MongoDB instance
   */

  await connect(process.env.MONGO_URI, {
    useNewUrlParser: true,
    useFindAndModify: false,
    useCreateIndex: true,
    useUnifiedTopology: true
  });

  /**
   * Fetch data from CLIST and store in MongoDB
   */

  const clist = await got('https://clist.by/api/v2/contest/', {
    headers: { Authorization: process.env.CLIST_BEARER },
    searchParams: {
      start__gt: new Date().toISOString(),
      start__lt: new Date(
        new Date().setDate(new Date().getDate() + 5)
      ).toISOString()
    }
  }).json();

  await Promise.all(
    clist.objects
      .filter(({ event }) => /^[ -~]+$/.test(event))
      .map(e => ({
        title: e.event,
        host: e.resource,
        url: e.href,
        start: e.start,
        end: e.end
      }))
      .map(storeIfNotExists)
  );

  /**
   * Fetch data from Devfolio and store in MongoDB
   */

  const devfolio = await got('https://devfolio.co/api/hackathons', {
    searchParams: {
      filter: 'application_open',
      page: 1,
      limit: 20
    }
  }).json();

  await Promise.all(
    devfolio.result
      .filter(
        ({ hackathon_setting: hs }) =>
          new Date(hs.reg_ends_at) <
          new Date(new Date().setDate(new Date().getDate() + 5))
      )
      .map(e => ({
        title: e.name,
        description: e.desc,
        host: 'devfolio.co',
        url: `https://${e.hackathon_setting.subdomain}.devfolio.co`,
        start: e.hackathon_setting.reg_starts_at,
        end: e.hackathon_setting.reg_ends_at,
        image: e.cover_img,
        thumbnail: e.hackathon_setting.logo
      }))
      .map(storeIfNotExists)
  );

  // /**
  //  * Fetch data from Devpost and store in MongoDB
  //  */

  const fetchData = async (url, searchParams, page = 1) => {
    const data = await got(url, {
      searchParams: Object.assign(searchParams, { page })
    }).json();

    const { total_count: totalCount, per_page: perPage } = data.meta;
    if (perPage * page >= totalCount) return data.hackathons;
    return [
      ...data.hackathons,
      ...(await fetchData(url, searchParams, page + 1))
    ];
  };

  const parseDate = str => {
    const matches = /^(\w{3})\s(\d{2}).*?(\d{4})/.exec(str);
    return new Date([...matches].splice(1).join(' '));
  };

  const devpost = (
    await fetchData('https://devpost.com/api/hackathons', {
      challenge_type: 'online',
      order_by: 'recently-added',
      status: 'upcoming'
    })
  ).filter(
    e =>
      parseDate(e.submission_period_dates) <
      new Date(new Date().setDate(new Date().getDate() + 7))
  );

  const getHackathonDetails = async url => {
    const dom = await JSDOM.fromURL(url);
    return JSON.parse(
      dom.window.document.querySelector('#challenge-json-ld').textContent
    );
  };

  const sanitizeText = async txt =>
    new TurndownService().turndown(
      new JSDOM(txt).window.document.body.textContent
    );

  await Promise.all(
    devpost.map(async e => {
      const data = await getHackathonDetails(e.url);
      await storeIfNotExists({
        title: e.title,
        description: await sanitizeText(data.description),
        host: 'devpost.com',
        url: e.url,
        start: data.startDate,
        end: data.endDate,
        image: data.image,
        thumbnail: `https:${e.thumbnail_url}`
      });
    })
  );

  /**
   * Generate and sanitize embeds
   */

  console.info(newEvents.length);

  const embeds = await Promise.all(
    newEvents.filter(e => !/hiring/i.test(e.title)).map(limitedEmbedGen)
  );
  const colors = getColors();

  embeds.forEach((element, i) => {
    if (!element.color)
      embeds[i].color =
        colors[psl.parse(new URL(element.author.url).hostname).domain] || 0;
  });

  embeds.sort(
    (a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
  );

  /**
   * Generate and send webhooks to Discord
   */

  const webhook = {
    content: null,
    embeds: []
  };

  const failed = [];

  while (embeds.length > 0) {
    webhook.embeds = embeds.splice(0, 1);
    if (webhook.embeds[0].color)
      try {
        // eslint-disable-next-line no-await-in-loop
        await got.post(process.env.WEBHOOK_URL, {
          json: webhook,
          responseType: 'json'
        });
      } catch (e) {
        console.error(e);
        failed.push(...webhook.embeds);
      }
  }

  console.warn(failed);

  await connection.close();
  process.exit();
})().catch(err => {
  console.error(err);
  process.exit(1);
});
